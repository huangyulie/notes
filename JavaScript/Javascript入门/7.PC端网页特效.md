# 一、元素偏移量offset系列

## 1.1 offset 概述

offset 翻译过来就是偏移量，我们使用offset系列相关属性可以动态的得到该元素的位置\大小等。

获得元素距离带有**定位父元素**的位置

获得元素自身的大小(宽度高度)

注意:返回的数值都**不带单位**

offset系列常用属性

|    offset系列属性    |                             作用                             |
| :------------------: | :----------------------------------------------------------: |
| element.offsetParent | 返回作为该元素带有定位的父级元素 如果父级都没有定位则返回body |
|  element.offsetTop   |             返回元素相对带有定位父元素上方的偏移             |
|  element.offsetLeft  |            返回元素相对带有定位父元素左边框的偏移            |
| element.offsetWidth  | **返回自身包括padding、边框、内容区的宽度**，返回数值不带单位 |
| element.offsetHeight | **返回自身包括padding、边框、内容区的高度**，返回数值不带单位 |

## 1.2 offset 与 style 区别

|                     offset                     |                     style                     |
| :--------------------------------------------: | :-------------------------------------------: |
|       offset可以得到任意样式表中的样式值       |       style只能得到行内样式表中的样式值       |
|        offset系列获得的数值是没有单位的        |       style系列获得的数值是单位的字符串       |
|      offsetWidth包含padding+border+width       |             offsetWidth只有width              |
| offsetWidth等属性是只读属性，只能获取不能赋值  | offsetWidth等属性是可读写属性，可以获取能赋值 |
| 所以，我们想要获取元素大小位置，用offset更合适 |  所以，我们想要给元素更改值，用stylet更合适   |

# 二、元素可视区client系列

## 2.1 概念

cilent翻译过来就是客户端，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态地得到该元素的边框大小，元素大小等.

|    client系列属性    |                             作用                             |
| :------------------: | :----------------------------------------------------------: |
|  element.clientTop   |                     返回元素上边框的大小                     |
|  element.clientLeft  |                     返回元素左边框的大小                     |
| element.clientWidth  | **返回自身包括padding、内容区的宽度、不含边框**、返回数值不带单位 |
| element.clientHeight | **返回自身包括padding、内容区的高度、不含边框**、返回数值不带单位 |

## 2.2 立即执行函数

不需要调用，立马能够自己执行得函数

写法：

<1>(function 名字( ){ }( ));

<2>(function 名字( ){ })( );

主要作用:创建一个独立的作用域，避免了命名冲突问题

# 三、元素滚动scroll系列

## 3.1 元素scroll系列属性

scroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态地得到该元素的大小，滚动距离等

|    scroll系列属性    |                    作用                    |
| :------------------: | :----------------------------------------: |
|  element.scrollTop   |     返回被卷去的上测距离，返回不带数值     |
|  element.scrollLeft  |     返回被卷去的左测距离，返回不带数值     |
| element.scrollWidth  | 返回自身实际的宽度，不含边框，返回不带数值 |
| element.scrollHeight | 返回自身实际的高度，不含边框，返回不带数值 |

## 3,2 被卷去的元素头部和页面不一样

盒子里面的元素是scrollTop (element.scrollTop)

盒子页面是pageYOffset，(window.pageYOffset)

# 四、mouseenter 和 mouseover的区别

mouseenter 鼠标事件。

<1>当鼠标移动到元素上时就会触发mouseenter事件.

<2>类似于mouseover,他们两者之间的差别是mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter只有经过自身盒子才会触发。

<3>因为mouseenter不会冒泡

# 五、动画函数封装

## 5.1 动画实现原理

核心原理：通过定时器setInterval( )不断移动盒子位置

实现步骤:

<1>获得盒子当前位置

<2>让盒子在当前位置加上1个移动距离

<3>利用定时器不断重复这个操作

<4>加一个结束定时器的条件

<5>注意此元素需要添加定位，才能使用element.style.left

## 5.2 动画函数简单封装

注意函数需要传递2个参数，动画对象和移动到的距离

先清除以前的定时器，只保留一个定时器就可以了

## 5.3 缓动效果原理

缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来。

思路:

<1>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来

<2>核心算法：（目标值-现在的位置） / 10;作为每次移动的距离步长
<3>停止的条件是:让当前盒子位置等于目标位置就停止定时器。

<4>步长值大于零，步长值要向上取整，小于零向下取整。

## 5.4 动画函数添加回调函数

回调函数:函数可以作为一个参数。将这个函数作为参数传给另一个函数里面，当那个函数执行完以后，在执行闯进去的这个函数，这个过程就叫回调。

# 六、节流阀

防止轮播图按钮连续点击造成播放过快。

节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无噶连续触发

核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数

开始设置一个变量 var flag = true;

if(flag) { flag = false ; do something} 关闭水龙头

利用回调函数，动画执行完毕，flag = true 打开水龙头
